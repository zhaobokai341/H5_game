<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Ping Pong - Single (Easy)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <div class="container">
    <h1>Ping Pong - Single Player (Easy)</h1>
    <div class="desc">Player: W/S or ↑/↓ or use the On-screen buttons (left). Pause: Space or center button. New ball every 10 seconds.</div>

    <div id="gameWrap">
      <canvas id="gameCanvas" width="800" height="500"></canvas>

      <div class="touch-controls left">
        <button id="btn-left-up" class="control-btn">Up</button>
        <button id="btn-left-down" class="control-btn">Down</button>
      </div>

      <!-- Center pause/resume button -->
      <div class="touch-controls center">
        <button id="btn-pause" class="control-btn pause" aria-label="Pause">Pause</button>
      </div>

      <div id="pausedText" class="paused">PAUSED</div>
    </div>
  </div>

  <script src="js/common.js"></script>
  <script src="js/ai.js"></script>
  <script>
    // Single-player easy with centralized pause
    const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
    const pauseBtn = document.getElementById('btn-pause');
    const paddleHeight = 100, paddleWidth = 15, ballSize = 15, paddleSpeed = 7;

    let leftPaddleY = PP.INTERNAL_HEIGHT / 2 - paddleHeight / 2;
    let rightPaddleY = PP.INTERNAL_HEIGHT / 2 - paddleHeight / 2;
    let leftScore = 0, rightScore = 0;

    const keys = PP.Input.initKeyboard();
    let leftTouchUp = false, leftTouchDown = false;
    PP.Input.setupButtons([
      { id: 'btn-left-up', onDown: v => leftTouchUp = v },
      { id: 'btn-left-down', onDown: v => leftTouchDown = v }
    ]);

    // Multi-ball state and spawner
    let balls = [];
    const state = { balls, paused: false, ballOpts: { size: ballSize } };
    const spawner = new PP.SpawnManager(state);

    // initial ball
    (function(){ const b = new PP.Ball({ size: ballSize }); b.vx = 5 * (Math.random() < 0.5 ? 1 : -1); b.vy = 3 * (Math.random() < 0.5 ? 1 : -1); balls.push(b); })();

    // Easy AI (track first ball only)
    const difficulty = { errorRange: 60, speedMultiplier: 0.4, relaxWhenAway: 0.4 };

    // Pause manager wired to spawner
    const pauseManager = new PP.PauseManager(state, spawner);
    const pauseControl = PP.UI.setupPauseButton('btn-pause', pauseManager, { pausedOverlayId: 'pausedText', pauseLabel: 'Pause', resumeLabel: 'Resume' });

    function updateAI() {
      if (balls.length === 0) return;
      const b = balls[0];
      if (b.vx > 0) {
        let time = (PP.INTERNAL_WIDTH - paddleWidth - 10 - b.x - b.size) / b.vx;
        if (time > 0) {
          let pred = b.y + b.vy * time;
          pred = PP.reflectPrediction(pred, b.size, PP.INTERNAL_HEIGHT);
          pred += (Math.random() * difficulty.errorRange - difficulty.errorRange / 2);
          let aiCenter = rightPaddleY + paddleHeight / 2;
          if (aiCenter < pred - 25) rightPaddleY += Math.max(1, paddleSpeed * difficulty.speedMultiplier);
          else if (aiCenter > pred + 25) rightPaddleY -= Math.max(1, paddleSpeed * difficulty.speedMultiplier);
          rightPaddleY = Math.max(0, Math.min(PP.INTERNAL_HEIGHT - paddleHeight, rightPaddleY));
        }
      } else {
        let target = PP.INTERNAL_HEIGHT / 2, aiCenter = rightPaddleY + paddleHeight / 2;
        if (aiCenter < target - 20) rightPaddleY += (paddleSpeed - 4) / 2;
        else if (aiCenter > target + 20) rightPaddleY -= (paddleSpeed - 4) / 2;
        rightPaddleY = Math.max(0, Math.min(PP.INTERNAL_HEIGHT - paddleHeight, rightPaddleY));
      }
    }

    function draw() {
      ctx.clearRect(0,0,PP.INTERNAL_WIDTH,PP.INTERNAL_HEIGHT);
      ctx.strokeStyle="#fff"; ctx.setLineDash([10,10]); ctx.beginPath(); ctx.moveTo(PP.INTERNAL_WIDTH/2,0); ctx.lineTo(PP.INTERNAL_WIDTH/2,PP.INTERNAL_HEIGHT); ctx.stroke(); ctx.setLineDash([]);
      ctx.font="36px Arial"; ctx.fillStyle="#fff"; ctx.fillText(leftScore, PP.INTERNAL_WIDTH/2 - 50, 50); ctx.fillText(rightScore, PP.INTERNAL_WIDTH/2 + 30, 50);
      ctx.fillStyle="#0f0"; ctx.fillRect(10, leftPaddleY, paddleWidth, paddleHeight);
      ctx.fillStyle="#f00"; ctx.fillRect(PP.INTERNAL_WIDTH - paddleWidth - 10, rightPaddleY, paddleWidth, paddleHeight);
      ctx.fillStyle="#fff"; balls.forEach(b => ctx.fillRect(b.x, b.y, b.size, b.size));
    }

    function update() {
      if (pauseManager.isPaused()) return;

      if (keys['w'] || keys['arrowup'] || leftTouchUp) leftPaddleY -= paddleSpeed;
      if (keys['s'] || keys['arrowdown'] || leftTouchDown) leftPaddleY += paddleSpeed;
      leftPaddleY = Math.max(0, Math.min(PP.INTERNAL_HEIGHT - paddleHeight, leftPaddleY));

      updateAI();

      for (let i = balls.length - 1; i >= 0; i--) {
        const ball = balls[i];
        ball.x += ball.vx; ball.y += ball.vy;
        if (ball.y <= 0 || ball.y + ball.size >= PP.INTERNAL_HEIGHT) ball.vy *= -1;

        if (ball.x <= 10 + paddleWidth && ball.y + ball.size >= leftPaddleY && ball.y <= leftPaddleY + paddleHeight) {
          let impact = ((ball.y + ball.size/2) - (leftPaddleY + paddleHeight/2)) / (paddleHeight/2);
          ball.vx = Math.abs(ball.vx); ball.vy += impact * 2; ball.x = 10 + paddleWidth;
        }

        if (ball.x + ball.size >= PP.INTERNAL_WIDTH - paddleWidth - 10 && ball.y + ball.size >= rightPaddleY && ball.y <= rightPaddleY + paddleHeight) {
          let impact = ((ball.y + ball.size/2) - (rightPaddleY + paddleHeight/2)) / (paddleHeight/2);
          ball.vx = -Math.abs(ball.vx); ball.vy += impact * 2; ball.x = PP.INTERNAL_WIDTH - paddleWidth - ball.size - 10;
        }

        if (ball.x < 0) { rightScore++; balls.splice(i,1); }
        else if (ball.x + ball.size > PP.INTERNAL_WIDTH) { leftScore++; balls.splice(i,1); }
      }
    }

    function loop() { update(); draw(); requestAnimationFrame(loop); }

    // Space key toggles pause and keep button label in sync
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        pauseManager.toggle();
        if (pauseControl && typeof pauseControl.updateButtonLabel === 'function') pauseControl.updateButtonLabel();
      }
    });

    // fit canvas and start
    PP.fitCanvasToCSS(canvas);
    window.addEventListener('resize', ()=>PP.fitCanvasToCSS(canvas));
    canvas.width = PP.INTERNAL_WIDTH; canvas.height = PP.INTERNAL_HEIGHT;

    // start spawn after first move
    (function startSpawnWhenFirstMoves(){
      let oldX = balls[0].x;
      function check(){
        if (!spawner.started && balls[0] && balls[0].x !== oldX) spawner.start();
        else { oldX = balls[0]?.x; requestAnimationFrame(check); }
      }
      check();
    })();

    loop();
  </script>
</body>
</html>