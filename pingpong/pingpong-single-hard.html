<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Ping Pong Game - Single Player (Hard)</title>
  <style>
    body {
      background: #222;
      color: #fff;
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 0;
      padding: 0;
    }
    h1 {
      margin-top: 20px;
    }
    #gameCanvas {
      background: #111;
      display: block;
      margin: 20px auto;
      border: 2px solid #fff;
      box-shadow: 0 0 15px #000;
    }
    .desc {
      font-size: 18px;
      margin-bottom: 10px;
      color: #ccc;
    }
    .paused {
      position: absolute;
      left: 0; right: 0;
      top: 45%;
      font-size: 64px;
      color: #ff0;
      font-weight: bold;
      text-shadow: 2px 2px 5px #000;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <h1>Ping Pong Game - Single Player (Hard)</h1>
  <div class="desc">Player: W/S or ↑/↓ &nbsp;&nbsp; Right: AI (Hard, Multi-ball) &nbsp;&nbsp; Space: Pause/Resume &nbsp;&nbsp; A new ball appears every 10 seconds!</div>
  <div id="pausedText" class="paused" style="display:none;">PAUSED</div>
  <canvas id="gameCanvas" width="800" height="500"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const pausedText = document.getElementById('pausedText');

    const paddleHeight = 100;
    const paddleWidth = 15;
    const ballSize = 15;
    const paddleSpeed = 7;

    let leftPaddleY = canvas.height / 2 - paddleHeight / 2;
    let rightPaddleY = canvas.height / 2 - paddleHeight / 2;
    let leftScore = 0;
    let rightScore = 0;

    let upPressed = false, downPressed = false;
    let wPressed = false, sPressed = false;

    let balls = [];
    let ballStarted = false;
    let ballIntervalId = null;
    let paused = false;

    class Ball {
      constructor() {
        this.x = canvas.width / 2 - ballSize / 2;
        this.y = canvas.height / 2 - ballSize / 2;
        let angle = Math.random() * Math.PI * 2;
        let speed = 5 + Math.random() * 2.5; // Slightly faster balls
        this.vx = Math.cos(angle) * speed;
        if (Math.abs(this.vx) < 2) this.vx = 2 * Math.sign(this.vx || 1);
        this.vy = Math.sin(angle) * speed;
      }
    }

    function createInitialBall() {
      const b = new Ball();
      b.vx = 7 * (Math.random() < 0.5 ? 1 : -1);
      b.vy = 5 * (Math.random() < 0.5 ? 1 : -1);
      balls.push(b);
    }

    function addBall() {
      balls.push(new Ball());
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = "#fff";
      ctx.setLineDash([10, 10]);
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, 0);
      ctx.lineTo(canvas.width / 2, canvas.height);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.font = "36px Arial";
      ctx.fillText(leftScore, canvas.width / 2 - 50, 50);
      ctx.fillText(rightScore, canvas.width / 2 + 30, 50);

      ctx.fillStyle = "#0f0";
      ctx.fillRect(10, leftPaddleY, paddleWidth, paddleHeight);

      ctx.fillStyle = "#f00";
      ctx.fillRect(canvas.width - paddleWidth - 10, rightPaddleY, paddleWidth, paddleHeight);

      balls.forEach(ball => {
        ctx.fillStyle = "#fff";
        ctx.fillRect(ball.x, ball.y, ballSize, ballSize);
      });
      if (paused) {
        pausedText.style.display = "";
      } else {
        pausedText.style.display = "none";
      }
    }

    // Hard AI: tracks all balls heading toward AI, minimal error, fast movement
    function updateAI() {
      if (balls.length === 0) return;

      let bestBall = null;
      let bestTime = Infinity;
      let bestPrediction = canvas.height / 2;

      for (let ball of balls) {
        if (ball.vx > 0) {
          let time = (canvas.width - paddleWidth - 10 - ball.x - ballSize) / ball.vx;
          if (time > 0 && time < bestTime) {
            let prediction = ball.y + ball.vy * time;
            while (prediction < 0 || prediction > canvas.height - ballSize) {
              if (prediction < 0) prediction = -prediction;
              else if (prediction > canvas.height - ballSize)
                prediction = 2 * (canvas.height - ballSize) - prediction;
            }
            prediction += Math.random() * 10 - 5; // Minimal error
            bestBall = ball;
            bestTime = time;
            bestPrediction = prediction;
          }
        }
      }

      let aiCenter = rightPaddleY + paddleHeight / 2;
      if (bestBall) {
        if (aiCenter < bestPrediction - 5) rightPaddleY += paddleSpeed  / 1.5;
        else if (aiCenter > bestPrediction + 5) rightPaddleY -= paddleSpeed / 1.5;
      } else {
        let target = canvas.height / 2;
        if (aiCenter < target - 5) rightPaddleY += (paddleSpeed + 2) / 2;
        else if (aiCenter > target + 5) rightPaddleY -= (paddleSpeed + 2) / 2;
      }
      rightPaddleY = Math.max(0, Math.min(canvas.height - paddleHeight, rightPaddleY));
    }

    function update() {
      if (paused) return;
      if (wPressed || upPressed) leftPaddleY -= paddleSpeed;
      if (sPressed || downPressed) leftPaddleY += paddleSpeed;
      leftPaddleY = Math.max(0, Math.min(canvas.height - paddleHeight, leftPaddleY));

      updateAI();

      for (let i = balls.length - 1; i >= 0; i--) {
        let ball = balls[i];
        ball.x += ball.vx;
        ball.y += ball.vy;

        if (ball.y <= 0 || ball.y + ballSize >= canvas.height) {
          ball.vy *= -1;
        }

        if (
          ball.x <= 10 + paddleWidth &&
          ball.y + ballSize >= leftPaddleY &&
          ball.y <= leftPaddleY + paddleHeight
        ) {
          let impact = ((ball.y + ballSize/2) - (leftPaddleY + paddleHeight/2)) / (paddleHeight/2);
          ball.vx = Math.abs(ball.vx);
          ball.vy += impact * 2;
          ball.x = 10 + paddleWidth;
        }

        if (
          ball.x + ballSize >= canvas.width - paddleWidth - 10 &&
          ball.y + ballSize >= rightPaddleY &&
          ball.y <= rightPaddleY + paddleHeight
        ) {
          let impact = ((ball.y + ballSize/2) - (rightPaddleY + paddleHeight/2)) / (paddleHeight/2);
          ball.vx = -Math.abs(ball.vx);
          ball.vy += impact * 2;
          ball.x = canvas.width - paddleWidth - ballSize - 10;
        }

        if (ball.x < 0) {
          rightScore++;
          balls.splice(i, 1);
        } else if (ball.x + ballSize > canvas.width) {
          leftScore++;
          balls.splice(i, 1);
        }
      }
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    document.addEventListener('keydown', (e) => {
      if (e.key === 'w' || e.key === 'W') wPressed = true;
      if (e.key === 's' || e.key === 'S') sPressed = true;
      if (e.key === 'ArrowUp') upPressed = true;
      if (e.key === 'ArrowDown') downPressed = true;
      if (e.code === 'Space') {
        paused = !paused;
        if (paused && ballIntervalId) {
          clearInterval(ballIntervalId);
          ballIntervalId = null;
        } else if (!paused && ballStarted && !ballIntervalId) {
          ballIntervalId = setInterval(() => {
            addBall();
          }, 10000);
        }
      }
    });
    document.addEventListener('keyup', (e) => {
      if (e.key === 'w' || e.key === 'W') wPressed = false;
      if (e.key === 's' || e.key === 'S') sPressed = false;
      if (e.key === 'ArrowUp') upPressed = false;
      if (e.key === 'ArrowDown') downPressed = false;
    });

    createInitialBall();
    gameLoop();

    function startBallSpawn() {
      if (ballStarted) return;
      ballStarted = true;
      if (!paused) {
        ballIntervalId = setInterval(() => {
          addBall();
        }, 10000);
      }
    }

    let oldBallX = balls[0].x;
    function firstMoveCheck() {
      if (!ballStarted && balls[0] && balls[0].x !== oldBallX) {
        startBallSpawn();
      } else {
        oldBallX = balls[0]?.x;
        requestAnimationFrame(firstMoveCheck);
      }
    }
    firstMoveCheck();
  </script>
</body>
</html>