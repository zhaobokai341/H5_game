<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Ping Pong - Two Player</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <div class="container">
    <h1>Ping Pong - Two Player</h1>
    <div class="desc">Left: W/S or left buttons. Right: ↑/↓ or right buttons. Space: Pause.</div>

    <div id="gameWrap">
      <canvas id="gameCanvas" width="800" height="500"></canvas>

      <div class="touch-controls left">
        <button id="btn-left-up" class="control-btn" aria-label="Left Up">Up</button>
        <button id="btn-left-down" class="control-btn" aria-label="Left Down">Down</button>
      </div>

      <div class="touch-controls right">
        <button id="btn-right-up" class="control-btn" aria-label="Right Up">Up</button>
        <button id="btn-right-down" class="control-btn" aria-label="Right Down">Down</button>
      </div>

      <div id="pausedText" class="paused">PAUSED</div>
    </div>
  </div>

  <script src="js/common.js"></script>
  <script>
    // Two-player logic: uses the shared helpers
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const pausedText = document.getElementById('pausedText');

    const paddleHeight = 100, paddleWidth = 15, ballSize = 15, paddleSpeed = 7;
    let leftPaddleY = PP.INTERNAL_HEIGHT / 2 - paddleHeight / 2;
    let rightPaddleY = PP.INTERNAL_HEIGHT / 2 - paddleHeight / 2;
    let leftScore = 0, rightScore = 0;

    // keyboard flags via PP.Input
    const keys = PP.Input.initKeyboard();

    // touch flags
    let leftTouchUp = false, leftTouchDown = false, rightTouchUp = false, rightTouchDown = false;
    // setup buttons
    PP.Input.setupButtons([
      { id: 'btn-left-up', onDown: (v) => leftTouchUp = v },
      { id: 'btn-left-down', onDown: (v) => leftTouchDown = v },
      { id: 'btn-right-up', onDown: (v) => rightTouchUp = v },
      { id: 'btn-right-down', onDown: (v) => rightTouchDown = v }
    ]);

    // ball state (single-ball for two-player)
    let ball = {
      x: PP.INTERNAL_WIDTH/2 - ballSize/2,
      y: PP.INTERNAL_HEIGHT/2 - ballSize/2,
      vx: 5 * (Math.random() < 0.5 ? 1 : -1),
      vy: 3 * (Math.random() < 0.5 ? 1 : -1),
      size: ballSize
    };

    let paused = false;
    function draw() {
      ctx.clearRect(0,0,PP.INTERNAL_WIDTH,PP.INTERNAL_HEIGHT);
      // center line
      ctx.strokeStyle = "#fff"; ctx.setLineDash([10,10]); ctx.beginPath();
      ctx.moveTo(PP.INTERNAL_WIDTH/2, 0); ctx.lineTo(PP.INTERNAL_WIDTH/2, PP.INTERNAL_HEIGHT); ctx.stroke(); ctx.setLineDash([]);
      // scores
      ctx.font = "36px Arial"; ctx.fillStyle = "#fff";
      ctx.fillText(leftScore, PP.INTERNAL_WIDTH/2 - 50, 50);
      ctx.fillText(rightScore, PP.INTERNAL_WIDTH/2 + 30, 50);
      // paddles
      ctx.fillStyle = "#0f0"; ctx.fillRect(10, leftPaddleY, paddleWidth, paddleHeight);
      ctx.fillStyle = "#f00"; ctx.fillRect(PP.INTERNAL_WIDTH - paddleWidth - 10, rightPaddleY, paddleWidth, paddleHeight);
      // ball
      ctx.fillStyle = "#fff"; ctx.fillRect(ball.x, ball.y, ball.size, ball.size);
      // paused overlay
      pausedText.style.display = paused ? "" : "none";
    }

    function update() {
      if (paused) return;
      // left paddle (keyboard W/S or pointer)
      if (keys['w'] || leftTouchUp) leftPaddleY -= paddleSpeed;
      if (keys['s'] || leftTouchDown) leftPaddleY += paddleSpeed;
      leftPaddleY = Math.max(0, Math.min(PP.INTERNAL_HEIGHT - paddleHeight, leftPaddleY));
      // right paddle (keyboard ArrowUp/ArrowDown or pointer)
      if (keys['ArrowUp'] || rightTouchUp) rightPaddleY -= paddleSpeed;
      if (keys['ArrowDown'] || rightTouchDown) rightPaddleY += paddleSpeed;
      rightPaddleY = Math.max(0, Math.min(PP.INTERNAL_HEIGHT - paddleHeight, rightPaddleY));

      // ball physics
      ball.x += ball.vx; ball.y += ball.vy;
      if (ball.y <= 0 || ball.y + ball.size >= PP.INTERNAL_HEIGHT) ball.vy *= -1;

      // collisions
      if (ball.x <= 10 + paddleWidth && ball.y + ball.size >= leftPaddleY && ball.y <= leftPaddleY + paddleHeight) {
        ball.vx = Math.abs(ball.vx); ball.x = 10 + paddleWidth;
      }
      if (ball.x + ball.size >= PP.INTERNAL_WIDTH - paddleWidth - 10 && ball.y + ball.size >= rightPaddleY && ball.y <= rightPaddleY + paddleHeight) {
        ball.vx = -Math.abs(ball.vx); ball.x = PP.INTERNAL_WIDTH - paddleWidth - ball.size - 10;
      }

      // scoring
      if (ball.x < 0) { rightScore++; resetBall(); }
      if (ball.x + ball.size > PP.INTERNAL_WIDTH) { leftScore++; resetBall(); }
    }

    function resetBall() {
      ball.x = PP.INTERNAL_WIDTH/2 - ball.size/2;
      ball.y = PP.INTERNAL_HEIGHT/2 - ball.size/2;
      ball.vx = 5 * (Math.random() < 0.5 ? 1 : -1);
      ball.vy = 3 * (Math.random() < 0.5 ? 1 : -1);
    }

    function loop() { update(); draw(); requestAnimationFrame(loop); }

    // Keyboard pause toggle
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        paused = !paused;
      }
    });

    // fit canvas scaling and start
    PP.fitCanvasToCSS(canvas);
    window.addEventListener('resize', () => PP.fitCanvasToCSS(canvas));
    // Set canvas internal resolution for drawing context
    canvas.width = PP.INTERNAL_WIDTH; canvas.height = PP.INTERNAL_HEIGHT;
    loop();
  </script>
</body>
</html>