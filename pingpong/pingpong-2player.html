<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Ping Pong Game - Two Player</title>
  <style>
    body {
      background: #222;
      color: #fff;
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 0;
      padding: 0;
    }
    h1 {
      margin-top: 20px;
    }
    #gameCanvas {
      background: #111;
      display: block;
      margin: 20px auto;
      border: 2px solid #fff;
      box-shadow: 0 0 15px #000;
    }
    .desc {
      font-size: 18px;
      margin-bottom: 10px;
      color: #ccc;
    }
    .paused {
      position: absolute;
      left: 0; right: 0;
      top: 45%;
      font-size: 64px;
      color: #ff0;
      font-weight: bold;
      text-shadow: 2px 2px 5px #000;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <h1>Ping Pong Game - Two Player</h1>
  <div class="desc">Left: W/S &nbsp;&nbsp; Right: ↑/↓ &nbsp;&nbsp; Space: Pause/Resume &nbsp;&nbsp; A new ball appears every 10 seconds!</div>
  <div id="pausedText" class="paused" style="display:none;">PAUSED</div>
  <canvas id="gameCanvas" width="800" height="500"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const pausedText = document.getElementById('pausedText');

    const paddleHeight = 100;
    const paddleWidth = 15;
    const ballSize = 15;
    const paddleSpeed = 7;

    let leftPaddleY = canvas.height / 2 - paddleHeight / 2;
    let rightPaddleY = canvas.height / 2 - paddleHeight / 2;
    let leftScore = 0;
    let rightScore = 0;

    let wPressed = false, sPressed = false;
    let upPressed = false, downPressed = false;

    // Ball management
    let balls = [];
    let ballStarted = false;
    let ballIntervalId = null;
    let paused = false;

    class Ball {
      constructor() {
        this.x = canvas.width / 2 - ballSize / 2;
        this.y = canvas.height / 2 - ballSize / 2;
        let angle = Math.random() * Math.PI * 2;
        let speed = 4 + Math.random() * 2;
        this.vx = Math.cos(angle) * speed;
        if (Math.abs(this.vx) < 2) this.vx = 2 * Math.sign(this.vx || 1);
        this.vy = Math.sin(angle) * speed;
      }
    }

    function createInitialBall() {
      const b = new Ball();
      b.vx = 5 * (Math.random() < 0.5 ? 1 : -1);
      b.vy = 3 * (Math.random() < 0.5 ? 1 : -1);
      balls.push(b);
    }

    function addBall() {
      balls.push(new Ball());
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Center line
      ctx.strokeStyle = "#fff";
      ctx.setLineDash([10, 10]);
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, 0);
      ctx.lineTo(canvas.width / 2, canvas.height);
      ctx.stroke();
      ctx.setLineDash([]);

      // Scores
      ctx.font = "36px Arial";
      ctx.fillText(leftScore, canvas.width / 2 - 50, 50);
      ctx.fillText(rightScore, canvas.width / 2 + 30, 50);

      ctx.fillStyle = "#0f0";
      ctx.fillRect(10, leftPaddleY, paddleWidth, paddleHeight);

      ctx.fillStyle = "#f00";
      ctx.fillRect(canvas.width - paddleWidth - 10, rightPaddleY, paddleWidth, paddleHeight);

      balls.forEach(ball => {
        ctx.fillStyle = "#fff";
        ctx.fillRect(ball.x, ball.y, ballSize, ballSize);
      });
      // Draw PAUSED overlay if paused
      if (paused) {
        pausedText.style.display = "";
      } else {
        pausedText.style.display = "none";
      }
    }

    function update() {
      if (paused) return;
      // Left paddle (W/S)
      if (wPressed) leftPaddleY -= paddleSpeed;
      if (sPressed) leftPaddleY += paddleSpeed;
      leftPaddleY = Math.max(0, Math.min(canvas.height - paddleHeight, leftPaddleY));

      // Right paddle (↑/↓)
      if (upPressed) rightPaddleY -= paddleSpeed;
      if (downPressed) rightPaddleY += paddleSpeed;
      rightPaddleY = Math.max(0, Math.min(canvas.height - paddleHeight, rightPaddleY));

      // Ball movement and collision
      for (let i = balls.length - 1; i >= 0; i--) {
        let ball = balls[i];
        ball.x += ball.vx;
        ball.y += ball.vy;

        // Top/bottom collision
        if (ball.y <= 0 || ball.y + ballSize >= canvas.height) {
          ball.vy *= -1;
        }

        // Paddle collision (Left)
        if (
          ball.x <= 10 + paddleWidth &&
          ball.y + ballSize >= leftPaddleY &&
          ball.y <= leftPaddleY + paddleHeight
        ) {
          ball.vx = Math.abs(ball.vx);
          ball.x = 10 + paddleWidth;
        }

        // Paddle collision (Right)
        if (
          ball.x + ballSize >= canvas.width - paddleWidth - 10 &&
          ball.y + ballSize >= rightPaddleY &&
          ball.y <= rightPaddleY + paddleHeight
        ) {
          ball.vx = -Math.abs(ball.vx);
          ball.x = canvas.width - paddleWidth - ballSize - 10;
        }

        // Left/Right wall (score or remove ball)
        if (ball.x < 0) {
          rightScore++;
          balls.splice(i, 1);
        } else if (ball.x + ballSize > canvas.width) {
          leftScore++;
          balls.splice(i, 1);
        }
      }
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    document.addEventListener('keydown', (e) => {
      if (e.key === 'w' || e.key === 'W') wPressed = true;
      if (e.key === 's' || e.key === 'S') sPressed = true;
      if (e.key === 'ArrowUp') upPressed = true;
      if (e.key === 'ArrowDown') downPressed = true;
      if (e.code === 'Space') {
        paused = !paused;
        // If paused, stop ball appearance interval
        if (paused && ballIntervalId) {
          clearInterval(ballIntervalId);
          ballIntervalId = null;
        } else if (!paused && ballStarted && !ballIntervalId) {
          ballIntervalId = setInterval(() => {
            addBall();
          }, 10000);
        }
      }
    });
    document.addEventListener('keyup', (e) => {
      if (e.key === 'w' || e.key === 'W') wPressed = false;
      if (e.key === 's' || e.key === 'S') sPressed = false;
      if (e.key === 'ArrowUp') upPressed = false;
      if (e.key === 'ArrowDown') downPressed = false;
    });

    // Start game
    createInitialBall();
    gameLoop();

    // Ball spawn logic: wait for first ball to move, then every 10s spawn
    function startBallSpawn() {
      if (ballStarted) return;
      ballStarted = true;
      if (!paused) {
        ballIntervalId = setInterval(() => {
          addBall();
        }, 10000);
      }
    }

    let oldBallX = balls[0].x;
    function firstMoveCheck() {
      if (!ballStarted && balls[0] && balls[0].x !== oldBallX) {
        startBallSpawn();
      } else {
        oldBallX = balls[0]?.x;
        requestAnimationFrame(firstMoveCheck);
      }
    }
    firstMoveCheck();
  </script>
</body>
</html>