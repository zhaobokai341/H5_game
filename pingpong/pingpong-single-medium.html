<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Ping Pong - Single (Medium)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <div class="container">
    <h1>Ping Pong - Single Player (Medium)</h1>
    <div class="desc">Use W/S or ↑/↓ or left on-screen buttons. Space: Pause. New ball every 10s.</div>

    <div id="gameWrap">
      <canvas id="gameCanvas" width="800" height="500"></canvas>

      <div class="touch-controls left">
        <button id="btn-left-up" class="control-btn">Up</button>
        <button id="btn-left-down" class="control-btn">Down</button>
      </div>

      <div id="pausedText" class="paused">PAUSED</div>
    </div>
  </div>

  <script src="js/common.js"></script>
  <script src="js/ai.js"></script>
  <script>
    // Single-player medium
    const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
    const pausedText = document.getElementById('pausedText');
    const paddleHeight = 100, paddleWidth = 15, ballSize = 15, paddleSpeed = 7;
    let leftPaddleY = PP.INTERNAL_HEIGHT/2 - paddleHeight/2, rightPaddleY = PP.INTERNAL_HEIGHT/2 - paddleHeight/2;
    let leftScore=0, rightScore=0;
    const keys = PP.Input.initKeyboard();
    let leftTouchUp=false, leftTouchDown=false;
    PP.Input.setupButtons([
      { id:'btn-left-up', onDown: v => leftTouchUp = v },
      { id:'btn-left-down', onDown: v => leftTouchDown = v }
    ]);
    let balls = [], paused=false;
    const state = { balls, paused, ballOpts: { size: ballSize } };
    const spawner = new PP.SpawnManager(state);

    // initial ball
    (function(){ let b = new PP.Ball({ size: ballSize }); b.vx = 5 * (Math.random() < 0.5 ? 1 : -1); b.vy = 3 * (Math.random() < 0.5 ? 1 : -1); balls.push(b); })();

    // AI difficulty (medium)
    const difficulty = { errorRange: 30, speedMultiplier: 0.5, relaxWhenAway: 0.6 };

    // Create a persistent reference object for AI to mutate
    const rightPaddleRef = { value: rightPaddleY };

    function draw(){
      ctx.clearRect(0,0,PP.INTERNAL_WIDTH,PP.INTERNAL_HEIGHT);
      ctx.strokeStyle="#fff"; ctx.setLineDash([10,10]); ctx.beginPath(); ctx.moveTo(PP.INTERNAL_WIDTH/2,0); ctx.lineTo(PP.INTERNAL_WIDTH/2,PP.INTERNAL_HEIGHT); ctx.stroke(); ctx.setLineDash([]);
      ctx.font="36px Arial"; ctx.fillStyle="#fff"; ctx.fillText(leftScore, PP.INTERNAL_WIDTH/2 - 50, 50); ctx.fillText(rightScore, PP.INTERNAL_WIDTH/2 + 30, 50);
      ctx.fillStyle="#0f0"; ctx.fillRect(10,leftPaddleY,paddleWidth,paddleHeight);
      ctx.fillStyle="#f00"; ctx.fillRect(PP.INTERNAL_WIDTH - paddleWidth - 10, rightPaddleY, paddleWidth, paddleHeight);
      ctx.fillStyle="#fff"; balls.forEach(b => ctx.fillRect(b.x, b.y, b.size, b.size));
      pausedText.style.display = paused ? "" : "none";
    }

    function update() {
      if (paused) return;
      if (keys['w'] || keys['arrowup'] || leftTouchUp) leftPaddleY -= paddleSpeed;
      if (keys['s'] || keys['arrowdown'] || leftTouchDown) leftPaddleY += paddleSpeed;
      leftPaddleY = Math.max(0, Math.min(PP.INTERNAL_HEIGHT - paddleHeight, leftPaddleY));

      // use multi-ball AI helper with persistent ref
      PP.AI.update(balls, rightPaddleRef, paddleHeight, paddleWidth, difficulty);
      // copy back mutated value
      rightPaddleY = Math.max(0, Math.min(PP.INTERNAL_HEIGHT - paddleHeight, rightPaddleRef.value));

      for (let i = balls.length -1; i >= 0; i--) {
        const ball = balls[i];
        ball.x += ball.vx; ball.y += ball.vy;
        if (ball.y <= 0 || ball.y + ball.size >= PP.INTERNAL_HEIGHT) ball.vy *= -1;
        if (ball.x <= 10 + paddleWidth && ball.y + ball.size >= leftPaddleY && ball.y <= leftPaddleY + paddleHeight) {
          let impact = ((ball.y + ball.size/2) - (leftPaddleY + paddleHeight/2)) / (paddleHeight/2);
          ball.vx = Math.abs(ball.vx); ball.vy += impact * 2; ball.x = 10 + paddleWidth;
        }
        if (ball.x + ball.size >= PP.INTERNAL_WIDTH - paddleWidth - 10 && ball.y + ball.size >= rightPaddleY && ball.y <= rightPaddleY + paddleHeight) {
          let impact = ((ball.y + ball.size/2) - (rightPaddleY + paddleHeight/2)) / (paddleHeight/2);
          ball.vx = -Math.abs(ball.vx); ball.vy += impact * 2; ball.x = PP.INTERNAL_WIDTH - paddleWidth - ball.size - 10;
        }
        if (ball.x < 0) { rightScore++; balls.splice(i,1); }
        else if (ball.x + ball.size > PP.INTERNAL_WIDTH) { leftScore++; balls.splice(i,1); }
      }
    }

    function loop(){ update(); draw(); requestAnimationFrame(loop); }

    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') { paused = !paused; state.paused = paused; if (paused) spawner.pause(); else spawner.resume(); }
    });

    PP.fitCanvasToCSS(canvas);
    window.addEventListener('resize', ()=>PP.fitCanvasToCSS(canvas));
    canvas.width = PP.INTERNAL_WIDTH; canvas.height = PP.INTERNAL_HEIGHT;

    (function startSpawnWhenFirstMoves(){
      let oldX = balls[0].x;
      function check(){
        if (!spawner.started && balls[0] && balls[0].x !== oldX) spawner.start();
        else { oldX = balls[0]?.x; requestAnimationFrame(check); }
      }
      check();
    })();

    loop();
  </script>
</body>
</html>